第一节：利用geckodirver启动firefox
      import java.util.concurrent.TimeUnit;
      import org.openqa.selenium.WebDriver;
      import org.openqa.selenium.firefox.FirefoxDriver;


      public class LanuchFirefox {

        public static void main(String[] args) throws InterruptedException {
          // TODO Auto-generated method stub
          //System.setProperty("webdriver.firefox.marionette", ".\\Tools\\geckodriver.exe"); 48版本以下
          
          //除了加入火狐驱动文件外，还需要配置firefox的路径
          System.setProperty("webdriver.gecko.driver", "D:\\Program Files\\eclipse-workspace\\Selenium_Lesson\\tools\\geckodriver.exe");
          System.setProperty("webdriver.firefox.bin", "D:\\Program Files\\Mozilla Firefox\\firefox.exe");

          WebDriver driver = new FirefoxDriver();
          driver.manage().window().maximize();
          //driver.manage().timeouts().implicitlyWait(8, TimeUnit.SECONDS);

          driver.get("https://www.baidu.com");
          Thread.sleep(5000);
          System.out.println("当前打开的页面标题是："+driver.getTitle());

          driver.quit();

        }
        
        总结：

              1. 介绍了Selenium 3.0上如何启动firefox版本大于48和低于48的情况

              2. driver.get() 是打开站点，传入的参数是url

              3. 知道了如何设置浏览器窗口最大化

              4. 知道了如何设置隐性等待时间；Thread.sleep(5000) （5s）

              5. driver.getTitle()是获取当前页面的title值，返回的是字符串对象

              6. driver.quit()是关闭并退出浏览器。
              

第二节：利用chromedriver自动化chrome
      import java.util.concurrent.TimeUnit;
      import org.openqa.selenium.WebDriver;
      import org.openqa.selenium.chrome.ChromeDriver;
      import org.openqa.selenium.chrome.ChromeOptions;

      public class LaunchChrome {

        public static void main(String[] args) throws InterruptedException {
          // TODO Auto-generated method stub

          System.setProperty("webdriver.chrome.driver", "./tools/chromedriver.exe");
          System.setProperty("webdriver.chrome.bin", "C:\\Users\\Administrator\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe");

          ChromeOptions opiions=new ChromeOptions();
          opiions.addArguments("--start-maximized");

          WebDriver driver = new ChromeDriver(opiions);
          String url = "https://www.baidu.com";
          driver.get(url);

          //driver.manage().window().maximize();  报错
          Thread.sleep(2000);
          System.out.println("当前页面的标题是："+driver.getTitle());

          driver.quit();
        }

    }
    

第三节：利用IEDriverServer自动化IE
      import java.util.concurrent.TimeUnit;
      import org.openqa.selenium.WebDriver;
      import org.openqa.selenium.ie.InternetExplorerDriver;;

      public class LaunchIE {

        public static void main(String[] args) throws InterruptedException{
          // TODO Auto-generated method stub
          System.setProperty("webdriver.ie.driver", "./tools/IEDriverServer.exe");
          
          //System.setProperty("webdriver.firefox.bin", "D:\\Program Files\\Mozilla Firefox\\firefox.exe"); IE安装在默认位置，不需要这一步

          WebDriver driver = new InternetExplorerDriver();
          driver.manage().window().maximize();
          //driver.manage().timeouts().implicitlyWait(8, TimeUnit.SECONDS);

          driver.get("https://www.baidu.com");
          Thread.sleep(5000);
          System.out.println("当前打开的页面标题是："+driver.getTitle());

          driver.quit();
        }

      }
    
    
第四节：
      自动化脚本编写比较容易，最大的困难去如何去写测试断言。
      自动化测试，最重要的还是落在测试上面，而不是自动化，自动化只是手段。
      断言的写法，就考验出一个测试工程师是否考虑全面，体现出你的用例编写水平。

      举例：验证打开链接是百度首页

      分析问题：我们输入了url，然后打开一个页面，如果判断这个页面是不是我们提前知道的页面呢。

            1. 获取当前url是不是和输入的一致，假如链接没有发生重定向。

            2. 获取当前页面title，是不是我们期待的结果。

            3. 在页面元素body找一个特征元素，这个特征元素能够代表是该网站。

             我想，也大概只有上面三点依据可以判断我们访问的网站对不对。
             第一点：盗链，输入一个网站URL，显示的内容是别人的网站，而不是你测试的网站，甚至有链接的重定向出现。
             第二点：title这个值是网站前端开发同学写入的，基本上可以代表是要打开的网站。
             第三点：有点难找这样的特征元素，而且有时候找到了也不一定是正确的。
             
             下面的代码就用页面的title来作为我们判断的依据：
                  




